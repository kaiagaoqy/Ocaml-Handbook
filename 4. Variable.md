### 1. `Type` Variables 
- To be able to tell unambiguously whether we are talking about values or types. 
- Type variables are written as a letter following a single-quote, e.g. 'a, 'b, 'c, etc.
Take int list \[1;2;3\] for example
	-  \[1;2;3\] : Square brackets [] (or infix ::) are the constructor for list _values_; 
	- `int list`: The postfix operator list is the constructor for list _types_.  In the type expression int list, the list type-constructor is applied to the type int to yield the type int list.
##### Type defination
1. an alias for a type that already exists
```ocaml
# type ilist = int list;;
type ilist = int list

# [1;2;3];; (* Still called int list*)
- : int list = [1; 2; 3]

# ilist [1;2;3];;
Error: Unbound value ilist
```
- To avoid ambiguity, OCaml doesn't automatically start calling every int list an ilist!!!
- Take a look at the example \[1;2;3\], if it can be defined as both int list and ilist, it will cause ambuigity to Ocaml


2. Name user-defined types
- `|` : constructor for variant types --> To prevent type ambiguous 
- The constructor names Int and String are arbitrary, but must start with Capital Letter to distinguish from variables 
-   The `of` indicates what type is under the wrapper, optionally no of meaning nothing under wrapper
-   Type declarations are required but once they are in place type inference on them works
```ocaml
# type intorstring = Int of int | String of string;;
type intorstring = Int of int | String of string
```

To construct a value of type intorstring, you apply one of the constructors (Int or String) to a value of the appropriate type:
```ocaml
# Int(5);;
- : intorstring = Int 5

# 5;;
- : int = 5
```

-   Each case of the union is identified by a name called a _constructor_ which serves for both
    -   constructing values of the variant type
    -   destructing them by pattern matching
	```ocaml
	type mynumber = Fixed of int | Floating of float;;  (* read "|" as "or" *)
	let add_num n1 n2 =
   match n1, n2 with    (* note use of pair here to parallel-match on two variables  *)
     | Fixed i1, Fixed i2 -> Fixed   (i1 + i2)
     | Fixed i1, Floating f2 -> Floating(float i1 +. f2) (* need to coerce with `float` function *)
     | Floating f1, Fixed i2 -> Floating(f1 +. float i2) (* ditto *)
     | Floating f1, Floating f2 -> Floating(f1 +. f2)
;;

	add_num (Fixed 10) (Floating 3.14159);;
	```
	Multiple data items in a single variant case? Use tuple types
	```ocaml

	type complex = CZero | Nonzero of float * float;;
	
	let com = Nonzero(3.2,11.2);;
	let zer = CZero;;
	```


#### Nullary Constructors
It's quite useful to define constructors that **don't take an argument;** these can be used to define what are often called _enumerated types_ in other languages. Suppose you're writing a program to play a card game:
```ocaml
    # type suit = Club | Diamond | Heart | Spade
      type value = Jack | Queen | King | Ace | Num of int
      type card = Card of value * suit
      type hand = card list
      ;;
    type suit = Club | Diamond | Heart | Spade
    type value = Jack | Queen | King | Ace | Num of int
    type card = Card of value * suit
    type hand = card list
    
    # Card (Ace, Spade);;
    - : card = Card (Ace, Spade)
    
    # ([Card(Ace, Spade); Card(Num 7, Heart)]:hand);;
    - : hand = [Card (Ace, Spade); Card (Num 7, Heart)]

```

Note: here I am doing something quite unusual in OCaml: explicitly specifying the type of a value by saying ([Card(Ace, Spade); Card(Num 7, Heart)]:hand), because otherwise [Card(Ace, Spade); Card(Num 7, Heart)] would be of type card list. The syntax for specifying the type of a value is (_expr_:_type_) — the parens are necessary.

### 2. Polymorphism
if there were only monomorphic list types, then you couldn't have a function that would compute the length of _any_ list: you'd have to define an int_list_length function, and a string_list_length function, and so on ad infinitum.

But OCaml lets you write _polymorphic_ functions that work for any type of list. The problem for a statically-typed language is: what is the type of such a function? Well, as we saw above, the domain of the built-in List.length functions is 'a list; the type variable 'a can be replaced with any type, so List.length works for any type of list: int list, string list, (int -> int) list, etc.

Some functions are polymorphic in more than one place: they use several different type variables. Within a given type expression, **all type variables must be used consistently**. So all the 'a's must refer to the same type, and all the 'b's must refer to the same type. (These two types might be the same.) This is exactly like simple value expressions, such as a + b / (2 * a), where each a must be the same value, and the b can be the same value or a different one.

``` ocaml
# List.map;;
- : ('a -> 'b) -> 'a list -> 'b list = <fun>
```

### 3. Recursive data structure