## 1. `Let` -- Naming Values
#### 1.1 `Let` variant can give names to values in **local** and **global** syntexs

``` ocaml
let name = expr1 in expr2;;
(* give expr1 the name within expr2*)
```
Local defination: name is only available in expr2, or we can say that the name is local to the body of `let`

examples:
```ocaml
 # let n = 2 in n*n;; (* int -> int *)
- : int = 4
```
One important difference from the other languages is that *the entire `Let` defination itself is an expression, where should return a value or function*

**EXPRESSION: EVERYTHING in OCaml RETURNS VALUES**

#### 1.2 `Let` can be nested
The let syntexs should be read inside out.
	1.  let a = 3 in a+b : int -> int = \<func\> ---> b+3
	2. let b = 2 in b+3 ---> 5
	3. let a = 1 in a+5 ---> 6 // stop
```ocaml
# let a = 1 in
  a + let b = 2  in
		    let a = 3 in
		      a+b;;
- : int = 6
```

#### 1.3 Full nested scope and Shadowing
1. Full nested scope: nested `let` establishes bindings that variables are all visible in the innermost `let` body
	- ex: let b = 2 is visible in a+b, to search for b, the innermost body will expand the searching to the nearest bound.(a=3 -> b =2)
2. shadowing: a name has a previous binding (in an outer scope) and you bind the same name again (like a in the above example); then the previous definded variable will be shadowed, and only the newest variable with the same name will be available
	- ex: when find (a + let b = 2) syntex, (a+b) will return with given a =3, b= 2; the syntex will not keep searching the next binding.
	- The value of the first a will not be overwritten!!!


#### 1.4 `let` and functions
To declare a function `squared` with `x` its one parameter. `return` is implicit.

``` OCaml
let squared x = x * x;; 
squared 4;; (* to call a function -- separate arguments with S P A C E S *)
```

-   OCaml has no `return` statement; value of the whole body-expression is what gets returned
-   Type is automatically **inferred** and printed as domain `->` range
-   OCaml functions in fact always take only one argument - ! multiple arguments can be encoded (later)

## 2. Functions
#### 2.1 How to define a function
##### Single Argument Function
``` ocaml
let add1 x = x + 1;; (* a normal add1 definition *)
let anon_add1 = (function x -> x + 1);; (* equivalent anonymous version; "x" is argument here *)
let anon_add1_fun = (fun x -> x + 1);; (* `function` can usually be shortened to `fun` *)

((fun x -> x + 1) 4) * 7;; (* can inline anonymous function definition; makes no sense here but will later *)

```
##### Multiple Arguments Functions
``` ocaml
# let add x y = x + y;;
val add : int -> int -> int = <fun>
add 3 4;;
(add 3) 4;; (* same meaning as previous application -- two applications, " " associates LEFT *)
```
- `add` is in fact a **higher-order function**: it returns a function as result.
- Observe `int -> int -> int` is parenthesized as `int -> (int -> int)` – unusual **right** associativity

``` ocaml

let add3 = add 3;; (* No need to give all arguments at once!  Type of add is int -> (int -> int) - "CURRIED" *)
# add3 4;;
- : int = 7

(+) 3 4;; (* Putting () around any infix operator turns it into a 2-argument function: `(+)` is same as our `add` above *)

```
Take care of the precedence!!

```ocaml
# add3 (2*3);;
- : int = 9

# add3 2*3;;
- : int = 15 (* NOT the previous - this is the same as (add3 3) * 2 - application binds tighter than `*` *)

# add3 @@ 2*3;;
- : int = 9 (* LIKE the original - @@ is like the " " for application but binds LOOSER than other ops *)
```
#### Declaring types in OCaml

While OCaml infers types for you it is often good practice to add those types to your code, e.g.

``` ocaml
let add (x : int) (y : int) : int = x + y;;
```

Note that the parentheses here are required, and the return type is at the end.
#### 2.2 How to call a function
- No paranthesis is needed
``` ocaml
# let add1 x = x + 1;;
val add1 : int -> int = <fun>

# add1 3;;(* Call Function *)
- : int = 4
```

#### 2.3 `let rec` Recursion
